{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/rache/Desktop/Hackathons/LockedIn/models/User.ts"],"sourcesContent":["import mongoose, { Schema, Document, Model } from 'mongoose';\r\n\r\nexport const GENDER_OPTIONS = ['male', 'female', 'non-binary', 'other', 'prefer_not_to_say'] as const;\r\nexport const SEXUALITY_OPTIONS = ['heterosexual', 'gay', 'lesbian', 'bisexual', 'pansexual', 'asexual', 'other', 'prefer_not_to_say'] as const;\r\n\r\nexport type Gender = typeof GENDER_OPTIONS[number];\r\nexport type Sexuality = typeof SEXUALITY_OPTIONS[number];\r\n\r\nexport interface IUser extends Document {\r\n    email: string;\r\n    passwordHash: string;\r\n    firstName?: string;\r\n    lastName?: string;\r\n    age?: number;\r\n    gender?: Gender;\r\n    sexuality?: Sexuality;\r\n    avatar?: string;\r\n    homeAddress?: string;\r\n    locationCoordinates?: {\r\n        lat: number;\r\n        lng: number;\r\n    };\r\n    interests: string;\r\n    values: string;\r\n    mustHaves: string;\r\n    niceToHaves: string;\r\n    dealBreakers: string;\r\n    status: 'onboarding' | 'waiting_for_match' | 'matched';\r\n    createdAt: Date;\r\n}\r\n\r\nconst UserSchema = new Schema<IUser>({\r\n    email: {\r\n        type: String,\r\n        required: true,\r\n        unique: true,\r\n        lowercase: true,\r\n        trim: true,\r\n        index: true\r\n    },\r\n    passwordHash: {\r\n        type: String,\r\n        required: true\r\n    },\r\n    firstName: {\r\n        type: String,\r\n        required: false\r\n    },\r\n    lastName: {\r\n        type: String,\r\n        required: false\r\n    },\r\n    age: {\r\n        type: Number,\r\n        required: false,\r\n        min: 18\r\n    },\r\n    avatar: {\r\n        type: String,\r\n        default: 'avatar1'\r\n    },\r\n    gender: {\r\n        type: String,\r\n        enum: GENDER_OPTIONS,\r\n        required: false\r\n    },\r\n    sexuality: {\r\n        type: String,\r\n        enum: SEXUALITY_OPTIONS,\r\n        required: false\r\n    },\r\n    homeAddress: {\r\n        type: String,\r\n        required: false\r\n    },\r\n    locationCoordinates: {\r\n        lat: {\r\n            type: Number,\r\n            required: false\r\n        },\r\n        lng: {\r\n            type: Number,\r\n            required: false\r\n        }\r\n    },\r\n    interests: {\r\n        type: String,\r\n        default: ''\r\n    },\r\n    values: {\r\n        type: String,\r\n        default: ''\r\n    },\r\n    mustHaves: {\r\n        type: String,\r\n        default: ''\r\n    },\r\n    niceToHaves: {\r\n        type: String,\r\n        default: ''\r\n    },\r\n    dealBreakers: {\r\n        type: String,\r\n        default: ''\r\n    },\r\n    status: {\r\n        type: String,\r\n        enum: ['onboarding', 'waiting_for_match', 'matched'],\r\n        default: 'onboarding',\r\n        required: true\r\n    },\r\n    createdAt: {\r\n        type: Date,\r\n        default: Date.now,\r\n        required: true\r\n    }\r\n});\r\n\r\n// Index for matching queries\r\nUserSchema.index({ status: 1 });\r\nUserSchema.index({ 'locationCoordinates.lat': 1, 'locationCoordinates.lng': 1 });\r\n\r\nconst User: Model<IUser> = mongoose.models.User || mongoose.model<IUser>('User', UserSchema);\r\n\r\nexport default User;\r\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAEO,MAAM,iBAAiB;IAAC;IAAQ;IAAU;IAAc;IAAS;CAAoB;AACrF,MAAM,oBAAoB;IAAC;IAAgB;IAAO;IAAW;IAAY;IAAa;IAAW;IAAS;CAAoB;AA4BrI,MAAM,aAAa,IAAI,kKAAM,CAAQ;IACjC,OAAO;QACH,MAAM;QACN,UAAU;QACV,QAAQ;QACR,WAAW;QACX,MAAM;QACN,OAAO;IACX;IACA,cAAc;QACV,MAAM;QACN,UAAU;IACd;IACA,WAAW;QACP,MAAM;QACN,UAAU;IACd;IACA,UAAU;QACN,MAAM;QACN,UAAU;IACd;IACA,KAAK;QACD,MAAM;QACN,UAAU;QACV,KAAK;IACT;IACA,QAAQ;QACJ,MAAM;QACN,SAAS;IACb;IACA,QAAQ;QACJ,MAAM;QACN,MAAM;QACN,UAAU;IACd;IACA,WAAW;QACP,MAAM;QACN,MAAM;QACN,UAAU;IACd;IACA,aAAa;QACT,MAAM;QACN,UAAU;IACd;IACA,qBAAqB;QACjB,KAAK;YACD,MAAM;YACN,UAAU;QACd;QACA,KAAK;YACD,MAAM;YACN,UAAU;QACd;IACJ;IACA,WAAW;QACP,MAAM;QACN,SAAS;IACb;IACA,QAAQ;QACJ,MAAM;QACN,SAAS;IACb;IACA,WAAW;QACP,MAAM;QACN,SAAS;IACb;IACA,aAAa;QACT,MAAM;QACN,SAAS;IACb;IACA,cAAc;QACV,MAAM;QACN,SAAS;IACb;IACA,QAAQ;QACJ,MAAM;QACN,MAAM;YAAC;YAAc;YAAqB;SAAU;QACpD,SAAS;QACT,UAAU;IACd;IACA,WAAW;QACP,MAAM;QACN,SAAS,KAAK,GAAG;QACjB,UAAU;IACd;AACJ;AAEA,6BAA6B;AAC7B,WAAW,KAAK,CAAC;IAAE,QAAQ;AAAE;AAC7B,WAAW,KAAK,CAAC;IAAE,2BAA2B;IAAG,2BAA2B;AAAE;AAE9E,MAAM,OAAqB,mKAAQ,CAAC,MAAM,CAAC,IAAI,IAAI,mKAAQ,CAAC,KAAK,CAAQ,QAAQ;uCAElE"}},
    {"offset": {"line": 177, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/rache/Desktop/Hackathons/LockedIn/models/Match.ts"],"sourcesContent":["import mongoose, { Schema, Document, Model } from 'mongoose';\r\n\r\nexport interface IMatch extends Document {\r\n    userA: mongoose.Types.ObjectId;\r\n    userB: mongoose.Types.ObjectId;\r\n    createdAt: Date;\r\n    status: 'active' | 'expired' | 'completed';\r\n    permanentlyBlocked: boolean;\r\n}\r\n\r\nconst MatchSchema = new Schema<IMatch>({\r\n    userA: {\r\n        type: Schema.Types.ObjectId,\r\n        ref: 'User',\r\n        required: true,\r\n        index: true\r\n    },\r\n    userB: {\r\n        type: Schema.Types.ObjectId,\r\n        ref: 'User',\r\n        required: true,\r\n        index: true\r\n    },\r\n    createdAt: {\r\n        type: Date,\r\n        default: Date.now,\r\n        required: true\r\n    },\r\n    status: {\r\n        type: String,\r\n        enum: ['active', 'expired', 'completed'],\r\n        default: 'active',\r\n        required: true\r\n    },\r\n    permanentlyBlocked: {\r\n        type: Boolean,\r\n        default: true,\r\n        required: true\r\n    }\r\n});\r\n\r\n// Compound indexes for efficient matching queries\r\nMatchSchema.index({ userA: 1, userB: 1 });\r\nMatchSchema.index({ userA: 1, status: 1 });\r\nMatchSchema.index({ userB: 1, status: 1 });\r\n\r\nconst Match: Model<IMatch> = mongoose.models.Match || mongoose.model<IMatch>('Match', MatchSchema);\r\n\r\nexport default Match;\r\n"],"names":[],"mappings":";;;;AAAA;;AAUA,MAAM,cAAc,IAAI,kKAAM,CAAS;IACnC,OAAO;QACH,MAAM,kKAAM,CAAC,KAAK,CAAC,QAAQ;QAC3B,KAAK;QACL,UAAU;QACV,OAAO;IACX;IACA,OAAO;QACH,MAAM,kKAAM,CAAC,KAAK,CAAC,QAAQ;QAC3B,KAAK;QACL,UAAU;QACV,OAAO;IACX;IACA,WAAW;QACP,MAAM;QACN,SAAS,KAAK,GAAG;QACjB,UAAU;IACd;IACA,QAAQ;QACJ,MAAM;QACN,MAAM;YAAC;YAAU;YAAW;SAAY;QACxC,SAAS;QACT,UAAU;IACd;IACA,oBAAoB;QAChB,MAAM;QACN,SAAS;QACT,UAAU;IACd;AACJ;AAEA,kDAAkD;AAClD,YAAY,KAAK,CAAC;IAAE,OAAO;IAAG,OAAO;AAAE;AACvC,YAAY,KAAK,CAAC;IAAE,OAAO;IAAG,QAAQ;AAAE;AACxC,YAAY,KAAK,CAAC;IAAE,OAAO;IAAG,QAAQ;AAAE;AAExC,MAAM,QAAuB,mKAAQ,CAAC,MAAM,CAAC,KAAK,IAAI,mKAAQ,CAAC,KAAK,CAAS,SAAS;uCAEvE"}},
    {"offset": {"line": 236, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/rache/Desktop/Hackathons/LockedIn/lib/db.ts"],"sourcesContent":["import mongoose from 'mongoose';\r\n\r\nconst MONGODB_URI = process.env.MONGODB_URI;\r\n\r\nif (!MONGODB_URI) {\r\n    throw new Error('Please define the MONGODB_URI environment variable inside .env.local');\r\n}\r\n\r\ninterface MongooseCache {\r\n    conn: typeof mongoose | null;\r\n    promise: Promise<typeof mongoose> | null;\r\n}\r\n\r\ndeclare global {\r\n    var mongoose: MongooseCache;\r\n}\r\n\r\nlet cached: MongooseCache = global.mongoose || { conn: null, promise: null };\r\n\r\nif (!global.mongoose) {\r\n    global.mongoose = cached;\r\n}\r\n\r\nasync function connectDB(): Promise<typeof mongoose> {\r\n    if (cached.conn) {\r\n        return cached.conn;\r\n    }\r\n\r\n    if (!cached.promise) {\r\n        const opts = {\r\n            bufferCommands: false,\r\n        };\r\n\r\n        cached.promise = mongoose.connect(MONGODB_URI!, opts).then((mongoose) => {\r\n            return mongoose;\r\n        });\r\n    }\r\n\r\n    try {\r\n        cached.conn = await cached.promise;\r\n    } catch (e) {\r\n        cached.promise = null;\r\n        throw e;\r\n    }\r\n\r\n    return cached.conn;\r\n}\r\n\r\nexport default connectDB;\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,cAAc,QAAQ,GAAG,CAAC,WAAW;AAE3C,IAAI,CAAC,aAAa;IACd,MAAM,IAAI,MAAM;AACpB;AAWA,IAAI,SAAwB,OAAO,QAAQ,IAAI;IAAE,MAAM;IAAM,SAAS;AAAK;AAE3E,IAAI,CAAC,OAAO,QAAQ,EAAE;IAClB,OAAO,QAAQ,GAAG;AACtB;AAEA,eAAe;IACX,IAAI,OAAO,IAAI,EAAE;QACb,OAAO,OAAO,IAAI;IACtB;IAEA,IAAI,CAAC,OAAO,OAAO,EAAE;QACjB,MAAM,OAAO;YACT,gBAAgB;QACpB;QAEA,OAAO,OAAO,GAAG,mKAAQ,CAAC,OAAO,CAAC,aAAc,MAAM,IAAI,CAAC,CAAC;YACxD,OAAO;QACX;IACJ;IAEA,IAAI;QACA,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;IACtC,EAAE,OAAO,GAAG;QACR,OAAO,OAAO,GAAG;QACjB,MAAM;IACV;IAEA,OAAO,OAAO,IAAI;AACtB;uCAEe"}},
    {"offset": {"line": 278, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/rache/Desktop/Hackathons/LockedIn/lib/matching.ts"],"sourcesContent":["import { GoogleGenerativeAI } from '@google/generative-ai';\r\nimport User from '@/models/User';\r\nimport Match from '@/models/Match';\r\nimport connectDB from '@/lib/db';\r\n\r\nconst genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY!);\r\n\r\nexport async function runMatchingAlgorithm() {\r\n    await connectDB();\r\n\r\n    const pool = await User.find({ status: 'waiting_for_match' });\r\n\r\n    if (pool.length < 2) {\r\n        return { matchesRaw: [], count: 0, message: 'Not enough users in pool' };\r\n    }\r\n\r\n    const candidates = pool.map(u => ({\r\n        id: u._id.toString(),\r\n        name: u.firstName,\r\n        age: u.age,\r\n        gender: u.gender,\r\n        sexuality: u.sexuality,\r\n        location: u.homeAddress,\r\n        interests: u.interests, // string\r\n        values: u.values,       // string\r\n        mustHaves: u.mustHaves, // string\r\n        dealBreakers: u.dealBreakers, // string\r\n    }));\r\n\r\n    const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });\r\n\r\n    const prompt = `\r\n    You are a professional matchmaker. Match these users based on their data.\r\n    \r\n    Constraints:\r\n    1. Users must be compatible based on gender/sexuality (Strict).\r\n    2. Respect \"Deal Breakers\" absolutely.\r\n    3. Return matches as pairs of IDs.\r\n    4. Each user can only be in ONE pair.\r\n    \r\n    Input Users (JSON):\r\n    ${JSON.stringify(candidates)}\r\n    \r\n    Output JSON Format (Array of pairs):\r\n    [\r\n      { \"userA\": \"id1\", \"userB\": \"id2\", \"reason\": \"High compatibility...\" }\r\n    ]\r\n    \r\n    Return ONLY valid JSON.\r\n  `;\r\n\r\n    try {\r\n        const result = await model.generateContent(prompt);\r\n        const response = await result.response;\r\n        let text = response.text();\r\n\r\n        text = text.replace(/```json/g, '').replace(/```/g, '').trim();\r\n\r\n        const pairs = JSON.parse(text);\r\n        const createdMatches = [];\r\n\r\n        for (const pair of pairs) {\r\n            const { userA, userB } = pair;\r\n\r\n            if (!userA || !userB) continue;\r\n\r\n            const validA = await User.findOne({ _id: userA, status: 'waiting_for_match' });\r\n            const validB = await User.findOne({ _id: userB, status: 'waiting_for_match' });\r\n\r\n            if (validA && validB) {\r\n                const match = await Match.create({\r\n                    userA: validA._id,\r\n                    userB: validB._id,\r\n                    status: 'active'\r\n                });\r\n\r\n                validA.status = 'matched';\r\n                await validA.save();\r\n\r\n                validB.status = 'matched';\r\n                await validB.save();\r\n\r\n                createdMatches.push(match);\r\n            }\r\n        }\r\n\r\n        return { matches: createdMatches, count: createdMatches.length };\r\n\r\n    } catch (error: any) {\r\n        console.error('Gemini Matching Error Detailed:', JSON.stringify(error, Object.getOwnPropertyNames(error)));\r\n        if (error.response) {\r\n            // Try/catch just in case accessing response.text() fails\r\n            try {\r\n                const errorText = await error.response.text();\r\n                console.error('Gemini Response Error:', errorText);\r\n            } catch (e) {\r\n                console.error('Could not read error response text');\r\n            }\r\n        }\r\n        throw error;\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA,MAAM,QAAQ,IAAI,sLAAkB,CAAC,QAAQ,GAAG,CAAC,cAAc;AAExD,eAAe;IAClB,MAAM,IAAA,sHAAS;IAEf,MAAM,OAAO,MAAM,2HAAI,CAAC,IAAI,CAAC;QAAE,QAAQ;IAAoB;IAE3D,IAAI,KAAK,MAAM,GAAG,GAAG;QACjB,OAAO;YAAE,YAAY,EAAE;YAAE,OAAO;YAAG,SAAS;QAA2B;IAC3E;IAEA,MAAM,aAAa,KAAK,GAAG,CAAC,CAAA,IAAK,CAAC;YAC9B,IAAI,EAAE,GAAG,CAAC,QAAQ;YAClB,MAAM,EAAE,SAAS;YACjB,KAAK,EAAE,GAAG;YACV,QAAQ,EAAE,MAAM;YAChB,WAAW,EAAE,SAAS;YACtB,UAAU,EAAE,WAAW;YACvB,WAAW,EAAE,SAAS;YACtB,QAAQ,EAAE,MAAM;YAChB,WAAW,EAAE,SAAS;YACtB,cAAc,EAAE,YAAY;QAChC,CAAC;IAED,MAAM,QAAQ,MAAM,kBAAkB,CAAC;QAAE,OAAO;IAAmB;IAEnE,MAAM,SAAS,CAAC;;;;;;;;;;IAUhB,EAAE,KAAK,SAAS,CAAC,YAAY;;;;;;;;EAQ/B,CAAC;IAEC,IAAI;QACA,MAAM,SAAS,MAAM,MAAM,eAAe,CAAC;QAC3C,MAAM,WAAW,MAAM,OAAO,QAAQ;QACtC,IAAI,OAAO,SAAS,IAAI;QAExB,OAAO,KAAK,OAAO,CAAC,YAAY,IAAI,OAAO,CAAC,QAAQ,IAAI,IAAI;QAE5D,MAAM,QAAQ,KAAK,KAAK,CAAC;QACzB,MAAM,iBAAiB,EAAE;QAEzB,KAAK,MAAM,QAAQ,MAAO;YACtB,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG;YAEzB,IAAI,CAAC,SAAS,CAAC,OAAO;YAEtB,MAAM,SAAS,MAAM,2HAAI,CAAC,OAAO,CAAC;gBAAE,KAAK;gBAAO,QAAQ;YAAoB;YAC5E,MAAM,SAAS,MAAM,2HAAI,CAAC,OAAO,CAAC;gBAAE,KAAK;gBAAO,QAAQ;YAAoB;YAE5E,IAAI,UAAU,QAAQ;gBAClB,MAAM,QAAQ,MAAM,4HAAK,CAAC,MAAM,CAAC;oBAC7B,OAAO,OAAO,GAAG;oBACjB,OAAO,OAAO,GAAG;oBACjB,QAAQ;gBACZ;gBAEA,OAAO,MAAM,GAAG;gBAChB,MAAM,OAAO,IAAI;gBAEjB,OAAO,MAAM,GAAG;gBAChB,MAAM,OAAO,IAAI;gBAEjB,eAAe,IAAI,CAAC;YACxB;QACJ;QAEA,OAAO;YAAE,SAAS;YAAgB,OAAO,eAAe,MAAM;QAAC;IAEnE,EAAE,OAAO,OAAY;QACjB,QAAQ,KAAK,CAAC,mCAAmC,KAAK,SAAS,CAAC,OAAO,OAAO,mBAAmB,CAAC;QAClG,IAAI,MAAM,QAAQ,EAAE;YAChB,yDAAyD;YACzD,IAAI;gBACA,MAAM,YAAY,MAAM,MAAM,QAAQ,CAAC,IAAI;gBAC3C,QAAQ,KAAK,CAAC,0BAA0B;YAC5C,EAAE,OAAO,GAAG;gBACR,QAAQ,KAAK,CAAC;YAClB;QACJ;QACA,MAAM;IACV;AACJ"}},
    {"offset": {"line": 396, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/rache/Desktop/Hackathons/LockedIn/app/api/match/run/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\r\nimport { runMatchingAlgorithm } from '@/lib/matching';\r\nimport { Resend } from 'resend';\r\nimport User from '@/models/User';\r\nimport connectDB from '@/lib/db';\r\n\r\nconst resend = new Resend(process.env.RESEND_API_KEY);\r\n\r\nexport async function POST(req: Request) {\r\n    try {\r\n        const result = await runMatchingAlgorithm();\r\n\r\n        if (result.matches && result.matches.length > 0) {\r\n            for (const match of result.matches) {\r\n                await connectDB();\r\n                const uA = await User.findById(match.userA);\r\n                const uB = await User.findById(match.userB);\r\n\r\n                if (uA && uB) {\r\n                    await sendMatchEmail(uA.email, uA.firstName || 'User', uB.firstName || 'your match');\r\n                    await sendMatchEmail(uB.email, uB.firstName || 'User', uA.firstName || 'your match');\r\n                }\r\n            }\r\n        }\r\n\r\n        return NextResponse.json({ success: true, result });\r\n    } catch (error) {\r\n        console.error('Match Run Error:', error);\r\n        return NextResponse.json({ error: error instanceof Error ? error.message : String(error) }, { status: 500 });\r\n    }\r\n}\r\n\r\nasync function sendMatchEmail(to: string, name: string, matchName: string) {\r\n    if (process.env.RESEND_API_KEY && !process.env.RESEND_API_KEY.includes('RESEND_API_KEY')) {\r\n        try {\r\n            await resend.emails.send({\r\n                from: 'LockedIn <onboarding@resend.dev>',\r\n                to: [to],\r\n                subject: 'You have a Match!',\r\n                html: `<p>Hi ${name},</p><p>You have been matched with <strong>${matchName}</strong>!</p><p>Go to the app to see next steps.</p>`\r\n            });\r\n        } catch (e) {\r\n            console.error(`[EMAIL FAIL] Failed to send to ${to}`, e);\r\n        }\r\n    } else {\r\n        console.log(`[EMAIL LOG] (Mock) Sending match email to ${to} for match with ${matchName}`);\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA,MAAM,SAAS,IAAI,oJAAM,CAAC,QAAQ,GAAG,CAAC,cAAc;AAE7C,eAAe,KAAK,GAAY;IACnC,IAAI;QACA,MAAM,SAAS,MAAM,IAAA,yIAAoB;QAEzC,IAAI,OAAO,OAAO,IAAI,OAAO,OAAO,CAAC,MAAM,GAAG,GAAG;YAC7C,KAAK,MAAM,SAAS,OAAO,OAAO,CAAE;gBAChC,MAAM,IAAA,sHAAS;gBACf,MAAM,KAAK,MAAM,2HAAI,CAAC,QAAQ,CAAC,MAAM,KAAK;gBAC1C,MAAM,KAAK,MAAM,2HAAI,CAAC,QAAQ,CAAC,MAAM,KAAK;gBAE1C,IAAI,MAAM,IAAI;oBACV,MAAM,eAAe,GAAG,KAAK,EAAE,GAAG,SAAS,IAAI,QAAQ,GAAG,SAAS,IAAI;oBACvE,MAAM,eAAe,GAAG,KAAK,EAAE,GAAG,SAAS,IAAI,QAAQ,GAAG,SAAS,IAAI;gBAC3E;YACJ;QACJ;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,SAAS;YAAM;QAAO;IACrD,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,oBAAoB;QAClC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG,OAAO;QAAO,GAAG;YAAE,QAAQ;QAAI;IAC9G;AACJ;AAEA,eAAe,eAAe,EAAU,EAAE,IAAY,EAAE,SAAiB;IACrE,IAAI,QAAQ,GAAG,CAAC,cAAc,IAAI,CAAC,QAAQ,GAAG,CAAC,cAAc,CAAC,QAAQ,CAAC,mBAAmB;QACtF,IAAI;YACA,MAAM,OAAO,MAAM,CAAC,IAAI,CAAC;gBACrB,MAAM;gBACN,IAAI;oBAAC;iBAAG;gBACR,SAAS;gBACT,MAAM,CAAC,MAAM,EAAE,KAAK,2CAA2C,EAAE,UAAU,qDAAqD,CAAC;YACrI;QACJ,EAAE,OAAO,GAAG;YACR,QAAQ,KAAK,CAAC,CAAC,+BAA+B,EAAE,IAAI,EAAE;QAC1D;IACJ,OAAO;QACH,QAAQ,GAAG,CAAC,CAAC,0CAA0C,EAAE,GAAG,gBAAgB,EAAE,WAAW;IAC7F;AACJ"}}]
}