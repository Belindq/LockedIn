{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/rache/Desktop/Hackathons/LockedIn/lib/db.ts"],"sourcesContent":["import mongoose from 'mongoose';\r\n\r\nconst MONGODB_URI = process.env.MONGODB_URI;\r\n\r\nif (!MONGODB_URI) {\r\n    throw new Error('Please define the MONGODB_URI environment variable inside .env.local');\r\n}\r\n\r\ninterface MongooseCache {\r\n    conn: typeof mongoose | null;\r\n    promise: Promise<typeof mongoose> | null;\r\n}\r\n\r\ndeclare global {\r\n    var mongoose: MongooseCache;\r\n}\r\n\r\nlet cached: MongooseCache = global.mongoose || { conn: null, promise: null };\r\n\r\nif (!global.mongoose) {\r\n    global.mongoose = cached;\r\n}\r\n\r\nasync function connectDB(): Promise<typeof mongoose> {\r\n    if (cached.conn) {\r\n        return cached.conn;\r\n    }\r\n\r\n    if (!cached.promise) {\r\n        const opts = {\r\n            bufferCommands: false,\r\n        };\r\n\r\n        cached.promise = mongoose.connect(MONGODB_URI!, opts).then((mongoose) => {\r\n            return mongoose;\r\n        });\r\n    }\r\n\r\n    try {\r\n        cached.conn = await cached.promise;\r\n    } catch (e) {\r\n        cached.promise = null;\r\n        throw e;\r\n    }\r\n\r\n    return cached.conn;\r\n}\r\n\r\nexport default connectDB;\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,cAAc,QAAQ,GAAG,CAAC,WAAW;AAE3C,IAAI,CAAC,aAAa;IACd,MAAM,IAAI,MAAM;AACpB;AAWA,IAAI,SAAwB,OAAO,QAAQ,IAAI;IAAE,MAAM;IAAM,SAAS;AAAK;AAE3E,IAAI,CAAC,OAAO,QAAQ,EAAE;IAClB,OAAO,QAAQ,GAAG;AACtB;AAEA,eAAe;IACX,IAAI,OAAO,IAAI,EAAE;QACb,OAAO,OAAO,IAAI;IACtB;IAEA,IAAI,CAAC,OAAO,OAAO,EAAE;QACjB,MAAM,OAAO;YACT,gBAAgB;QACpB;QAEA,OAAO,OAAO,GAAG,mKAAQ,CAAC,OAAO,CAAC,aAAc,MAAM,IAAI,CAAC,CAAC;YACxD,OAAO;QACX;IACJ;IAEA,IAAI;QACA,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;IACtC,EAAE,OAAO,GAAG;QACR,OAAO,OAAO,GAAG;QACjB,MAAM;IACV;IAEA,OAAO,OAAO,IAAI;AACtB;uCAEe"}},
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/rache/Desktop/Hackathons/LockedIn/models/User.ts"],"sourcesContent":["import mongoose, { Schema, Document, Model } from 'mongoose';\r\n\r\nexport const GENDER_OPTIONS = ['male', 'female', 'non-binary', 'other', 'prefer_not_to_say'] as const;\r\nexport const SEXUALITY_OPTIONS = ['heterosexual', 'gay', 'lesbian', 'bisexual', 'pansexual', 'asexual', 'other', 'prefer_not_to_say'] as const;\r\n\r\nexport type Gender = typeof GENDER_OPTIONS[number];\r\nexport type Sexuality = typeof SEXUALITY_OPTIONS[number];\r\n\r\nexport interface IUser extends Document {\r\n    email: string;\r\n    passwordHash: string;\r\n    firstName: string;\r\n    lastName: string;\r\n    age: number;\r\n    gender: Gender;\r\n    sexuality: Sexuality;\r\n    homeAddress: string;\r\n    locationCoordinates: {\r\n        lat: number;\r\n        lng: number;\r\n    };\r\n    interests: string;\r\n    values: string;\r\n    mustHaves: string;\r\n    niceToHaves: string;\r\n    dealBreakers: string;\r\n    status: 'onboarding' | 'idle' | 'waiting_for_match' | 'matched';\r\n    createdAt: Date;\r\n}\r\n\r\nconst UserSchema = new Schema<IUser>({\r\n    email: {\r\n        type: String,\r\n        required: true,\r\n        unique: true,\r\n        lowercase: true,\r\n        trim: true,\r\n        index: true\r\n    },\r\n    passwordHash: {\r\n        type: String,\r\n        required: true\r\n    },\r\n    firstName: {\r\n        type: String,\r\n        required: true\r\n    },\r\n    lastName: {\r\n        type: String,\r\n        required: true\r\n    },\r\n    age: {\r\n        type: Number,\r\n        required: true,\r\n        min: 18\r\n    },\r\n    gender: {\r\n        type: String,\r\n        enum: GENDER_OPTIONS,\r\n        required: true\r\n    },\r\n    sexuality: {\r\n        type: String,\r\n        enum: SEXUALITY_OPTIONS,\r\n        required: true\r\n    },\r\n    homeAddress: {\r\n        type: String,\r\n        required: true\r\n    },\r\n    locationCoordinates: {\r\n        lat: {\r\n            type: Number,\r\n            required: true\r\n        },\r\n        lng: {\r\n            type: Number,\r\n            required: true\r\n        }\r\n    },\r\n    interests: {\r\n        type: String,\r\n        default: ''\r\n    },\r\n    values: {\r\n        type: String,\r\n        default: ''\r\n    },\r\n    mustHaves: {\r\n        type: String,\r\n        default: ''\r\n    },\r\n    niceToHaves: {\r\n        type: String,\r\n        default: ''\r\n    },\r\n    dealBreakers: {\r\n        type: String,\r\n        default: ''\r\n    },\r\n    status: {\r\n        type: String,\r\n        enum: ['onboarding', 'idle', 'waiting_for_match', 'matched'],\r\n        default: 'onboarding',\r\n        required: true\r\n    },\r\n    createdAt: {\r\n        type: Date,\r\n        default: Date.now,\r\n        required: true\r\n    }\r\n});\r\n\r\n// Index for matching queries\r\nUserSchema.index({ status: 1 });\r\nUserSchema.index({ 'locationCoordinates.lat': 1, 'locationCoordinates.lng': 1 });\r\n\r\nconst User: Model<IUser> = mongoose.models.User || mongoose.model<IUser>('User', UserSchema);\r\n\r\nexport default User;\r\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAEO,MAAM,iBAAiB;IAAC;IAAQ;IAAU;IAAc;IAAS;CAAoB;AACrF,MAAM,oBAAoB;IAAC;IAAgB;IAAO;IAAW;IAAY;IAAa;IAAW;IAAS;CAAoB;AA2BrI,MAAM,aAAa,IAAI,kKAAM,CAAQ;IACjC,OAAO;QACH,MAAM;QACN,UAAU;QACV,QAAQ;QACR,WAAW;QACX,MAAM;QACN,OAAO;IACX;IACA,cAAc;QACV,MAAM;QACN,UAAU;IACd;IACA,WAAW;QACP,MAAM;QACN,UAAU;IACd;IACA,UAAU;QACN,MAAM;QACN,UAAU;IACd;IACA,KAAK;QACD,MAAM;QACN,UAAU;QACV,KAAK;IACT;IACA,QAAQ;QACJ,MAAM;QACN,MAAM;QACN,UAAU;IACd;IACA,WAAW;QACP,MAAM;QACN,MAAM;QACN,UAAU;IACd;IACA,aAAa;QACT,MAAM;QACN,UAAU;IACd;IACA,qBAAqB;QACjB,KAAK;YACD,MAAM;YACN,UAAU;QACd;QACA,KAAK;YACD,MAAM;YACN,UAAU;QACd;IACJ;IACA,WAAW;QACP,MAAM;QACN,SAAS;IACb;IACA,QAAQ;QACJ,MAAM;QACN,SAAS;IACb;IACA,WAAW;QACP,MAAM;QACN,SAAS;IACb;IACA,aAAa;QACT,MAAM;QACN,SAAS;IACb;IACA,cAAc;QACV,MAAM;QACN,SAAS;IACb;IACA,QAAQ;QACJ,MAAM;QACN,MAAM;YAAC;YAAc;YAAQ;YAAqB;SAAU;QAC5D,SAAS;QACT,UAAU;IACd;IACA,WAAW;QACP,MAAM;QACN,SAAS,KAAK,GAAG;QACjB,UAAU;IACd;AACJ;AAEA,6BAA6B;AAC7B,WAAW,KAAK,CAAC;IAAE,QAAQ;AAAE;AAC7B,WAAW,KAAK,CAAC;IAAE,2BAA2B;IAAG,2BAA2B;AAAE;AAE9E,MAAM,OAAqB,mKAAQ,CAAC,MAAM,CAAC,IAAI,IAAI,mKAAQ,CAAC,KAAK,CAAQ,QAAQ;uCAElE"}},
    {"offset": {"line": 222, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/rache/Desktop/Hackathons/LockedIn/lib/auth.ts"],"sourcesContent":["import { SignJWT, jwtVerify } from 'jose';\r\n\r\nconst secret = new TextEncoder().encode(process.env.JWT_SECRET);\r\n\r\nexport async function signSession(payload: { userId: string; email: string }) {\r\n    const alg = 'HS256';\r\n    return new SignJWT(payload)\r\n        .setProtectedHeader({ alg })\r\n        .setIssuedAt()\r\n        .setExpirationTime('7d')\r\n        .sign(secret);\r\n}\r\n\r\nexport async function verifySession(token: string) {\r\n    try {\r\n        const { payload } = await jwtVerify(token, secret);\r\n        return payload;\r\n    } catch (error) {\r\n        return null;\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;;AAEA,MAAM,SAAS,IAAI,cAAc,MAAM,CAAC,QAAQ,GAAG,CAAC,UAAU;AAEvD,eAAe,YAAY,OAA0C;IACxE,MAAM,MAAM;IACZ,OAAO,IAAI,kKAAO,CAAC,SACd,kBAAkB,CAAC;QAAE;IAAI,GACzB,WAAW,GACX,iBAAiB,CAAC,MAClB,IAAI,CAAC;AACd;AAEO,eAAe,cAAc,KAAa;IAC7C,IAAI;QACA,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,IAAA,sKAAS,EAAC,OAAO;QAC3C,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,OAAO;IACX;AACJ"}},
    {"offset": {"line": 250, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/rache/Desktop/Hackathons/LockedIn/lib/address.ts"],"sourcesContent":["export async function validateAddress(address: string): Promise<{ isValid: boolean, coordinates?: { lat: number, lng: number }, formattedAddress?: string }> {\r\n    try {\r\n        const response = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(address)}&format=json&limit=1`, {\r\n            headers: {\r\n                'User-Agent': 'LockedInApp/1.0' // Nominatim requires a User-Agent\r\n            }\r\n        });\r\n\r\n        if (!response.ok) {\r\n            console.error('Address validation failed:', response.statusText);\r\n            return { isValid: false };\r\n        }\r\n\r\n        const data = await response.json();\r\n\r\n        if (data && data.length > 0) {\r\n            const result = data[0];\r\n            return {\r\n                isValid: true,\r\n                coordinates: {\r\n                    lat: parseFloat(result.lat),\r\n                    lng: parseFloat(result.lon)\r\n                },\r\n                formattedAddress: result.display_name\r\n            };\r\n        }\r\n\r\n        return { isValid: false };\r\n\r\n    } catch (error) {\r\n        console.error('Error validating address:', error);\r\n        // In case of API failure, we might want to fail safe or block. \r\n        // For now, let's treat network error as invalid address to be safe, \r\n        // or we could throw to let the caller decide.\r\n        return { isValid: false };\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAO,eAAe,gBAAgB,OAAe;IACjD,IAAI;QACA,MAAM,WAAW,MAAM,MAAM,CAAC,6CAA6C,EAAE,mBAAmB,SAAS,oBAAoB,CAAC,EAAE;YAC5H,SAAS;gBACL,cAAc,kBAAkB,kCAAkC;YACtE;QACJ;QAEA,IAAI,CAAC,SAAS,EAAE,EAAE;YACd,QAAQ,KAAK,CAAC,8BAA8B,SAAS,UAAU;YAC/D,OAAO;gBAAE,SAAS;YAAM;QAC5B;QAEA,MAAM,OAAO,MAAM,SAAS,IAAI;QAEhC,IAAI,QAAQ,KAAK,MAAM,GAAG,GAAG;YACzB,MAAM,SAAS,IAAI,CAAC,EAAE;YACtB,OAAO;gBACH,SAAS;gBACT,aAAa;oBACT,KAAK,WAAW,OAAO,GAAG;oBAC1B,KAAK,WAAW,OAAO,GAAG;gBAC9B;gBACA,kBAAkB,OAAO,YAAY;YACzC;QACJ;QAEA,OAAO;YAAE,SAAS;QAAM;IAE5B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,gEAAgE;QAChE,qEAAqE;QACrE,8CAA8C;QAC9C,OAAO;YAAE,SAAS;QAAM;IAC5B;AACJ"}},
    {"offset": {"line": 296, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/rache/Desktop/Hackathons/LockedIn/app/api/auth/signup/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\r\nimport bcrypt from 'bcryptjs';\r\nimport connectDB from '@/lib/db';\r\nimport User from '@/models/User';\r\nimport { signSession } from '@/lib/auth';\r\nimport { validateAddress } from '@/lib/address';\r\n\r\nexport async function POST(req: Request) {\r\n    try {\r\n        await connectDB();\r\n        let body;\r\n        try {\r\n            body = await req.json();\r\n        } catch (e) {\r\n            return NextResponse.json({ error: 'Invalid JSON body', details: 'Request body is empty or malformed' }, { status: 400 });\r\n        }\r\n\r\n        const { email, password, firstName, lastName, age, gender, sexuality, homeAddress } = body;\r\n\r\n        // Basic field validation\r\n        if (!email || !password || !firstName || !lastName || !age || !gender || !sexuality || !homeAddress) {\r\n            return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });\r\n        }\r\n\r\n        // Validate address\r\n        const addressValidation = await validateAddress(homeAddress);\r\n        if (!addressValidation.isValid || !addressValidation.coordinates) {\r\n            return NextResponse.json({ error: 'Invalid address', details: 'Unable to verify the provided home address' }, { status: 400 });\r\n        }\r\n\r\n        const locationCoordinates = addressValidation.coordinates;\r\n\r\n        const existingUser = await User.findOne({ email });\r\n        if (existingUser) {\r\n            return NextResponse.json({ error: 'User already exists' }, { status: 409 });\r\n        }\r\n\r\n        const passwordHash = await bcrypt.hash(password, 10);\r\n\r\n        const user = await User.create({\r\n            email,\r\n            passwordHash,\r\n            firstName,\r\n            lastName,\r\n            age,\r\n            gender,\r\n            sexuality,\r\n            homeAddress: addressValidation.formattedAddress || homeAddress, // Use formatted address if available\r\n            locationCoordinates,\r\n            status: 'onboarding',\r\n        });\r\n\r\n        const token = await signSession({ userId: user._id.toString(), email: user.email });\r\n\r\n        const response = NextResponse.json({ success: true, user: { email: user.email, id: user._id } });\r\n        response.cookies.set('session', token, {\r\n            httpOnly: true,\r\n            secure: process.env.NODE_ENV === 'production',\r\n            sameSite: 'lax',\r\n            path: '/',\r\n        });\r\n\r\n        return response;\r\n    } catch (error) {\r\n        console.error('Signup error:', error);\r\n        return NextResponse.json({ error: 'Internal Server Error', details: error instanceof Error ? error.message : String(error) }, { status: 500 });\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAEO,eAAe,KAAK,GAAY;IACnC,IAAI;QACA,MAAM,IAAA,sHAAS;QACf,IAAI;QACJ,IAAI;YACA,OAAO,MAAM,IAAI,IAAI;QACzB,EAAE,OAAO,GAAG;YACR,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;gBAAqB,SAAS;YAAqC,GAAG;gBAAE,QAAQ;YAAI;QAC1H;QAEA,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,EAAE,MAAM,EAAE,SAAS,EAAE,WAAW,EAAE,GAAG;QAEtF,yBAAyB;QACzB,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,aAAa,CAAC,YAAY,CAAC,OAAO,CAAC,UAAU,CAAC,aAAa,CAAC,aAAa;YACjG,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA0B,GAAG;gBAAE,QAAQ;YAAI;QACjF;QAEA,mBAAmB;QACnB,MAAM,oBAAoB,MAAM,IAAA,mIAAe,EAAC;QAChD,IAAI,CAAC,kBAAkB,OAAO,IAAI,CAAC,kBAAkB,WAAW,EAAE;YAC9D,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;gBAAmB,SAAS;YAA6C,GAAG;gBAAE,QAAQ;YAAI;QAChI;QAEA,MAAM,sBAAsB,kBAAkB,WAAW;QAEzD,MAAM,eAAe,MAAM,2HAAI,CAAC,OAAO,CAAC;YAAE;QAAM;QAChD,IAAI,cAAc;YACd,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAsB,GAAG;gBAAE,QAAQ;YAAI;QAC7E;QAEA,MAAM,eAAe,MAAM,8IAAM,CAAC,IAAI,CAAC,UAAU;QAEjD,MAAM,OAAO,MAAM,2HAAI,CAAC,MAAM,CAAC;YAC3B;YACA;YACA;YACA;YACA;YACA;YACA;YACA,aAAa,kBAAkB,gBAAgB,IAAI;YACnD;YACA,QAAQ;QACZ;QAEA,MAAM,QAAQ,MAAM,IAAA,4HAAW,EAAC;YAAE,QAAQ,KAAK,GAAG,CAAC,QAAQ;YAAI,OAAO,KAAK,KAAK;QAAC;QAEjF,MAAM,WAAW,gJAAY,CAAC,IAAI,CAAC;YAAE,SAAS;YAAM,MAAM;gBAAE,OAAO,KAAK,KAAK;gBAAE,IAAI,KAAK,GAAG;YAAC;QAAE;QAC9F,SAAS,OAAO,CAAC,GAAG,CAAC,WAAW,OAAO;YACnC,UAAU;YACV,QAAQ,oDAAyB;YACjC,UAAU;YACV,MAAM;QACV;QAEA,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,iBAAiB;QAC/B,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;YAAyB,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG,OAAO;QAAO,GAAG;YAAE,QAAQ;QAAI;IAChJ;AACJ"}}]
}